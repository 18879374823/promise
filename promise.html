
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>promise</title>
</head>
<body>
    
</body>
<!-- MDN -->
<!-- 准备工作 -->
<script>
    // 1、构造函数
    // 2、bind，call，
    // 3、回调函数
    /*
    1、函数对象与实例对象
        函数对象：将函数作为对象使用
        实例对象：new 函数产生的对象
    */
    // function Fn() { // Fn函数
    // }
    // const fn = new Fn(); // Fn  是构造函数  fn是实例对象（简称对象）
    // // Fn.prototype Fn是函数对象（将函数作为对象使用）
    // Fn.bind({}); 


    /*
    2、两种类型的回调函数
        1、同步回调：
            立即执行，完全执行完了才结束，不会放入回调队列中
            如：数组遍历相关的回调函数/ Promise的excutor函数
        2、异步回调：
            不会立即执行，会放入回调队列中将来执行
            如：定时器回调/ajax回调/Promise的成功or失败回调
    */
    // 1、同步回调函数
    // const arr = [1,3,5];
    // arr.forEach(item => { // 不会放入队列中，会顺序执行
    //     console.log(item); //  先执行
    // })
    // console.log('forEach()之后');// 后执行
    // // 即顺序执行
    // //2、异步回调函数
    // setTimeout(() => { // 异步回调函数，会放入队列中将来执行
    //     console.log('timeOut callBack()');// 后执行
    // }, 0);
    // console.log('setTimeout()之后'); // 先执行


    /*
    3、js的error处理   https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error
        1、错误类型
            Error：所有错误的父类型
            Reference: 引用的变量不存在
            TypeError：数据类型不正确的错误
            RangeError：数据值不在其所允许的范围内
            SyntacError：语法错误
        2、错误处理
            捕获错误：try ... catch
            抛出错误：throw error
        3、错误对象
            message属性：错误相关信息
            stack属性：函数调用栈记录信息
    */


    /* 1、常见的内置错误
        1）：Reference
        console.log(a); // a未定义，直接打印就会报错
        报错：promise.html:69 Uncaught ReferenceError: a is not defined at promise.html:69  // Uncaught：没有被处理，所以不会继续往下执行
        2）：TypeError
        const b = null;
        console.log(b.xxx); // b中并没有xxx，会报错
        报错：Uncaught TypeError: Cannot read property 'xxx' of null at promise.html:73
        3）：RangeError
        function fn2(){ //  递归调用，无限循环里，而函数调用是有个限制的
            fn2();
        }
        fn2();
        报错：Uncaught RangeError: Maximum call stack size exceeded
        // 4）SyntacError
    */ 
    /* 
        2、处理错误
    */
    // 1、捕获错误，如
    // try {
    //     let a;
    //     console.log(a.xxx);
    // } catch (error){
    //     console.log(error);
    //     // error里有两个属性：message和stack
    //     console.log(error.message); // Cannot read property 'xxx' of undefined
    //     console.log(error.stack);// TypeError: Cannot read property 'xxx' of undefined at promise.html:89
    // }
    // // 2、抛出错误 throw error
    // function something() {
    //     if(Date.now()%2===1) {
    //         console.log('当时间为奇数，可以执行任务');
    //     } else { // 抛出异常，由调用来处理
    //         throw new Error('当前时间为偶数，无法执行任务'); // 一般都是抛出Error
    //     }
    // }
    // // 抛出错误之后，要捕获异常，这样有异常来才能去做处理
    // try {
    //     something();
    // } catch(error){
    //     alert(error.message);
    // }
</script>

<!-- Promise 的理解和使用 -->
<script>
    /*
    1、Promise是什么  https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise
        1）：抽象表达：
            Promise 是JS中进行异步编程的新的解决方案（旧的是什么？纯回调形式）
        2）：具体表达：
            从语法上来看，Promise是一个构造函数
            从功能上来讲，Promise对象用来封装一个异步操作并可以获取其结果
    2、promise的状态改变（一共有三个状态：pending，resolved，rejected）
        1）：pending 变为 resolved
        2）：pending 变为 rejected
        状态改变只有这两种，且一个promise对象只能改变一次
        无论变为成功还是失败，都会有一个结果数据
        成功的结果数据一般称为value，失败的结果数据一般称为reason
    3、promise的基本流程（图稍后补充）
        new Promise（新建一个promise对象）---> 执行异步操作
    4、promise的基本使用
    */
   // 4、primise的基本使用
   //  首先创建一个promise对象，放进一个回调函数，回调函数有两个参数，分别是 resolve 和 reject，如果成功，则调用resolve函数，如果失败，则调用 reject函数，他们又会返回一个promise对象，在最开始创建的对象的 then里，可以接收这两个返回的对象，在catch里仅能接收失败返回的对象
   // 1、创建一个新的promise对象
   const p = new Promise((resolve, reject) => { // 执行器函数
        // 2、执行异步任务
        setTimeout(() => {
            const time = Date.now();
            // 3.1 成功，调用resolve(value) (如果当前时间为偶数，则为成功，否则代表失败)
            if(time%2 == 0){
                resolve('成功的数据，time：'+time);
            }
            else{
            // 3.2 失败，调用reject(reason)
                reject('失败的数据，time：'+time);
            }
        },1000);
        

   });
   p.then(
       value => { // 接收得到成功的value数据  onResolved
            console.log('成功的回调',value);
       },
       reason => { // 接收得到reason的数据  onRejected
            console.log('失败的回调', reason);
       }
   )

   /*
    为什么要用promise
    1、指定回调函数的方式更灵活
       旧的：必须在启动异步任务前指定
       promise：启动异步任务-->返回promise对象-->给promise对象绑定回调函数（甚至可以异步任务结束后指定多个）
    2、支持链式调用，可以解决回调地狱问题
       什么是回调地狱：回调函数嵌套使用，外部回调函数异步执行的结果是嵌套的回调函数的执行的条件
       回调地狱的缺点：不便于阅读，不便于错误处理
       解决方案：promise链式调用
       终极解决方案：async/await

       发展顺序：
        0、回调地狱
        1、promise 的链式调用解决回调地狱（因为还有回调函数，所以不是最优解）
        2、async/await ：回调地狱的终极解决方案
   */


    /*
        如何使用Promise
        1、API(语法)
            1）Promise 的构造函数：Promise(excutor){}
            excutor函数：执行器函数 (resolve,reject) =>{}
            resolve函数：内部定义成功时，我们调用的函数 value => {}
            reject函数：内部定义失败时我们调用的函数 reason => {}
            excutor会在Promise内部立即同步回调，异步操做在执行器中执行
            2）Promise.prototype.then方法：(OnResolved,OnRejected) => {}
            OnResolved函数：成功的回调韩式 value =>{}
            OnRejected函数：失败的回调函数 reason ={}
            指定用于得到成功value的成功回调和用于得到失败reason的失败回调，返回一个新的promise对象
            3）Promise.prototype.catch方法： (OnRejected) =>{}
            OnRejected函数：失败的回调函数 (reason) =>{}
            then()的语法糖，相当于：then(undefined, OnRejected)
            4）Promise.resolve方法：（value）=> {}
            value:成功的数据或promise对象
            返回一个成功/失败的promise对象
            5）Promise.reject方法：(reason) => {}
            reason:失败的原因
            返回一个失败的promise对象
            6）Promise.all方法：(promise) => {}
            promise:包含n个promise数组
            返回一个新的promise，只有所有的promise都成功才成功，只要有一个失败了就直接失败
            7）Promise.race方法：(promise) => {}
            promise:包含n个promise数组
            返回一个新的promise，第一个完成的promise的结果状态就是最终的结果状态
    */
    new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve('成功的数据');
            // reject('失败的数据'); // 第二个在这里其实是没有意义的，因为状态只会执行一次
        },1000)
    }).then((value) => {
        console.log('onResolved()1', value);
    }).catch((reason) => {
        console.log('onReject()1',reason);
    })
    // 产生一个成功值为1的promise对象
    const p1 = new Promise((resolve, reject) => {
        resolve(1);
    })
    const p2 = Promise.resolve(2); // 语法糖：产生一个成功值为2的promise对象
    const p3 = Promise.reject(3); // 语法糖：产生一个失败值为3的promise对象
    // 这个时候p1,p2,p3均为一个promise对象，要想获得具体的值，需要在then或catch中去获取
    p1.then(value => {console.log('p1:', value)});
    p2.then(value => {console.log('p2:', value)});
    // 失败可以有两种打印
    p3.then(null, (reason) => {console.log('p3:',reason)});
    p3.catch((reason) => {console.log('p3:', reason)});

    // all：
    const pAll = Promise.all([p1,p2,p3]);
    pAll.then(
        value => {
            console.log('all onResolved()', value);
        },
        reason => {
            console.log('all Onrejected()', reason); // 出错的那一个返回值（错误原因）
        }
        )
    const pAll2 = Promise.all([p1,p2]);
    pAll2.then(
        values => {
            console.log('all onResolved()', value);// 全部成功，则返回一个数组，与promise数组一致
        },
        reason => {
            console.log('all Onrejected()', reason); // 出错的那一个返回值（错误原因）
        }
        )
    // race:第一个执行完成的是什么就是什么
    const pRace = Promise.race([p1,p2,p3]);
    pRace.then(
        (value) => {
            console.log(value);
        },
        (reason) => {
            console.log(reason);
        }
    )
</script>
</html>
</html>